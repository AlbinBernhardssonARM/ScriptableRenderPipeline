#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel CSMainFirstH FIRST HORIZONTAL    KerName=CSMainFirstH
#pragma kernel CSMainFirstV FIRST VERTICAL      KerName=CSMainFirstV
#pragma kernel CSMainH      HORIZONTAL          KerName=CSMainH
#pragma kernel CSMainV      VERTICAL            KerName=CSMainV

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesFunctions.hlsl"

  Texture2D<float>  _Input;
RWTexture2D<float>  _Output;

uint                _Iteration;
uint4               _Sizes; // xy: InputSize; zw: OutputSize

#define _InputSize  _Sizes.xy
#define _OutputSize _Sizes.zw

#ifdef HORIZONTAL
    #define THREAD_PER_GROUP_X 8
    #define THREAD_PER_GROUP_Y 1
#else // if VERTICAL
    #define THREAD_PER_GROUP_X 1
    #define THREAD_PER_GROUP_Y 8
#endif

#define OutType float

OutType GetInput(uint2 pos)
{
    return _Input[pos];
}

#ifdef FIRST
[numthreads(8, 8, 1)]
void KerName(uint3 id : SV_DispatchThreadID)
{
    if (all(id.xy < _OutputSize))
    {
        //_Output[id.xy] = SampleToPDFMeasure(_Input[id.xy].rgb);
        _Output[id.xy] = _Input[id.xy].xx;
        //_Output[id.xy] = dot(_Input[id.xy].rgb, (1.0f).xxx).xxxx;
    }
}
#else
// Ref: Hillis & Steele Parallel Scan Algorithm (Prefix Sum)
[numthreads(THREAD_PER_GROUP_X, THREAD_PER_GROUP_Y, 1)]
void KerName(uint3 id : SV_DispatchThreadID)
{
    if (all(id.xy < _OutputSize))
    {
        uint i;
    #ifdef HORIZONTAL
        uint k = id.x;
    #else
        uint k = id.y;
    #endif
        const uint off = uint(_Iteration);
        OutType inVal = _Input[id.xy];
        if (k >= off)
        {
    #ifdef HORIZONTAL
            _Output[id.xy] = //1.0f;
                (inVal + _Input[uint2(id.x - off, id.y      )]);
    #else
            _Output[id.xy] = //1.0f;
                (inVal + _Input[uint2(id.x      , id.y - off)]);
    #endif
        }
        else
        {
            _Output[id.xy] = inVal;
        }
    }
}
#endif
