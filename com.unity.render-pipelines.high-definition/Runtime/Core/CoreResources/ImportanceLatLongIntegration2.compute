#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel CSMain32   KerName=CSMain32   ThreadsCount=32
#pragma kernel CSMain64   KerName=CSMain64   ThreadsCount=64
#pragma kernel CSMain512  KerName=CSMain512  ThreadsCount=512
//#pragma kernel CSMain1024 KerName=CSMain1024 ThreadsCount=1024

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

  Texture2D<float4> _Input;
  Texture2D<float4> _Integral;
  Texture2D<float4> _Samples;
RWTexture2D<float4> _Output;

uint4               _Sizes; // xy: InputSize; zw: OutputSize
uint                _SamplesPerThread;
float4              _Params; // x: 1/_SamplesPerThread, yzw: 0

#define _InvSamplesPerThread _Params.x

#define _InputSize  _Sizes.xy
#define _OutputSize _Sizes.zw

SAMPLER(sampler_LinearClamp);

groupshared float4 localSphereIntegration   [ThreadsCount];
groupshared float4 localCosHemiIntegration  [ThreadsCount];
groupshared float4 localHemiIntegration     [ThreadsCount];

[numthreads(ThreadsCount, 1, 1)]
void KerName(uint3 id : SV_DispatchThreadID)
{
    float4 sphereSum    = 0.0f;
    float4 hemiCosSum   = 0.0f;
    float4 hemiSum      = 0.0f;
    float weight = 0.0f;
    for (uint i = 0; i < _SamplesPerThread; ++i)
    {
        uint   idx      = id.x*_SamplesPerThread + i;

        float2 uv       = _Samples[uint2(idx, 0)].xy;
        float3 L        = normalize(LatlongToDirectionCoordinate(uv));
        float3 Lwi      = SAMPLE_TEXTURE2D_LOD(_Input, sampler_LinearClamp, uv, 0).xyz;
        float  LwiMax   = max(Lwi.r, max(Lwi.g, Lwi.b));
        float  sin0i    = sin(uv.y*PI);
        float  jac      = 1.0f/max(abs(sin0i), 1e-4f);

        float4 measure  = float4(Lwi, LwiMax);

        float NdoL = max(L.z, 0);

        //sphereSum   += measure*jac;
        sphereSum   += measure*sin0i;
        hemiCosSum  += measure*NdoL*sin0i;
        hemiSum     += measure*sin0i;
        weight      += NdoL > 0.0f ? 1.0f : 0.0f;
    }
    float invHemiUsedSamplesCount = 1.0f/max(weight, 1e-4);
    sphereSum   *= _InvSamplesPerThread;
    hemiCosSum  *= invHemiUsedSamplesCount;
    hemiSum     *= invHemiUsedSamplesCount;

    localSphereIntegration  [id.x] = sphereSum;
    localCosHemiIntegration [id.x] = hemiCosSum;
    localHemiIntegration    [id.x] = hemiSum;

    GroupMemoryBarrierWithGroupSync();

    ///// TODO fix that
    if (id.x == 0)
    {
        const float invThreadsCount = 1.0f/float(ThreadsCount);
        float4 accSph       = 0.0f;
        float4 accCosHemi   = 0.0f;
        float4 accHemi      = 0.0f;
        for (uint i = 0; i < ThreadsCount; ++i)
        {
            accSph      += localSphereIntegration   [i];
            accCosHemi  += localCosHemiIntegration  [i];
            accHemi     += localHemiIntegration     [i];
        }
        accSph      *= invThreadsCount;
        accCosHemi  *= invThreadsCount;
        accHemi     *= invThreadsCount;

        _Output[uint2(0, 0)] = accSph;
        _Output[uint2(1, 0)] = accCosHemi;
        _Output[uint2(2, 0)] = accHemi;
    }
}
